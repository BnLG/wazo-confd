#!/usr/bin/python
# -*- coding: UTF-8 -*-

# Copyright (C) 2012  Avencall
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA..


import logging
import sys
import argparse
from xivo import daemonize
from xivo_recording.services.service_manager import ServiceManager

DAEMONNAME = 'xivo_recording'

# Enable debug mode for testing witout gevent WSGi,
# setting to True activates the internal web server
#DEBUG_MODE = True

LOGFILENAME = '/tmp/%s.log' % DAEMONNAME
PIDFILE = '/var/run/%s.pid' % DAEMONNAME


def main():
    parsed_args = _parse_args(sys.argv[1:])
    _init_logging(parsed_args.debug)

    if(parsed_args.dev_mode):
        # flask http server
        serviceManager = ServiceManager()
        serviceManager.run()
    else:
        # nginx connection via gevent
#        from gevent.wsgi import WSGIServer
#        from xivo_recording.rest.flask_http_server import app
        from tornado.wsgi import WSGIContainer
        from tornado.httpserver import HTTPServer
        from tornado.ioloop import IOLoop
        from xivo_recording.rest.flask_http_server import app

        if not parsed_args.debug:
            _daemonize()
#        http_server = WSGIServer(('127.0.0.1', 50050), app)
#        http_server.serve_forever()
        http_server = HTTPServer(WSGIContainer(app))
        http_server.listen(50050)
        IOLoop.instance().start()


def _init_logging(debug_mode):
    logger = logging.getLogger()
    formatter = logging.Formatter('%%(asctime)s %s[%%(process)d] (%%(levelname)s) (%%(name)s): %%(message)s'
                                  % DAEMONNAME)
    if debug_mode:
        handler = logging.StreamHandler()
        handler.setFormatter(formatter)
        logger.addHandler(handler)
        logger.setLevel(logging.DEBUG)
    else:
        logger.setLevel(logging.INFO)

    logfilehandler = logging.FileHandler(LOGFILENAME)
    logfilehandler.setFormatter(formatter)
    logger.addHandler(logfilehandler)


def _daemonize():
    daemonize.daemonize()
    daemonize.lock_pidfile_or_die(PIDFILE)


def _parse_args(args):
    parser = _new_parser()
    return parser.parse_args(args)


def _new_parser():
    parser = argparse.ArgumentParser()
    parser.add_argument('-d', '--debug', action='store_true')
    parser.add_argument('--dev_mode', action='store_true')
    return parser


if __name__ == '__main__':
    main()
